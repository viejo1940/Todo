{"version":3,"sources":["../../../../../src/client/components/react-dev-overlay/utils/stack-frame.ts"],"sourcesContent":["import type { StackFrame } from 'next/dist/compiled/stacktrace-parser'\nimport type {\n  OriginalStackFrameResponse,\n  OriginalStackFrameResponseResult,\n  OriginalStackFramesRequest,\n} from '../server/shared'\nimport {\n  isWebpackInternalResource,\n  formatFrameSourceFile,\n} from './webpack-module-path'\nexport interface OriginalStackFrame extends OriginalStackFrameResponse {\n  error: boolean\n  reason: string | null\n  external: boolean\n  ignored: boolean\n  sourceStackFrame: StackFrame\n}\n\nfunction getOriginalStackFrame(\n  source: StackFrame,\n  response: OriginalStackFrameResponseResult\n): Promise<OriginalStackFrame> {\n  async function _getOriginalStackFrame(): Promise<OriginalStackFrame> {\n    if (response.status === 'rejected') {\n      return Promise.reject(new Error(response.reason))\n    }\n\n    const body: OriginalStackFrameResponse = response.value\n\n    return {\n      error: false,\n      reason: null,\n      external: false,\n      sourceStackFrame: source,\n      originalStackFrame: body.originalStackFrame,\n      originalCodeFrame: body.originalCodeFrame || null,\n      sourcePackage: body.sourcePackage,\n      ignored: body.originalStackFrame?.ignored || false,\n    }\n  }\n\n  // TODO: merge this section into ignoredList handling\n  if (source.file === 'file://' || source.file?.match(/https?:\\/\\//)) {\n    return Promise.resolve({\n      error: false,\n      reason: null,\n      external: true,\n      sourceStackFrame: source,\n      originalStackFrame: null,\n      originalCodeFrame: null,\n      sourcePackage: null,\n      ignored: true,\n    })\n  }\n\n  return _getOriginalStackFrame().catch((err: Error) => ({\n    error: true,\n    reason: err?.message ?? err?.toString() ?? 'Unknown Error',\n    external: false,\n    sourceStackFrame: source,\n    originalStackFrame: null,\n    originalCodeFrame: null,\n    sourcePackage: null,\n    ignored: false,\n  }))\n}\n\nexport async function getOriginalStackFrames(\n  frames: StackFrame[],\n  type: 'server' | 'edge-server' | null,\n  isAppDir: boolean\n): Promise<OriginalStackFrame[]> {\n  const req: OriginalStackFramesRequest = {\n    frames,\n    isServer: type === 'server',\n    isEdgeServer: type === 'edge-server',\n    isAppDirectory: isAppDir,\n  }\n\n  let res: Response | undefined = undefined\n  let reason: string | undefined = undefined\n  try {\n    res = await fetch('/__nextjs_original-stack-frames', {\n      method: 'POST',\n      body: JSON.stringify(req),\n    })\n  } catch (e) {\n    reason = e + ''\n  }\n\n  // When fails to fetch the original stack frames, we reject here to be\n  // caught at `_getOriginalStackFrame()` and return the stack frames so\n  // that the error overlay can render.\n  if (res && res.ok && res.status !== 204) {\n    const data = await res.json()\n    return Promise.all(\n      frames.map((frame, index) => getOriginalStackFrame(frame, data[index]))\n    )\n  } else {\n    if (res) {\n      reason = await res.text()\n    }\n  }\n  return Promise.all(\n    frames.map((frame) =>\n      getOriginalStackFrame(frame, {\n        status: 'rejected',\n        reason: `Failed to fetch the original stack frames ${reason ? `: ${reason}` : ''}`,\n      })\n    )\n  )\n}\n\nexport function getFrameSource(frame: StackFrame): string {\n  if (!frame.file) return ''\n\n  const isWebpackFrame = isWebpackInternalResource(frame.file)\n\n  let str = ''\n  // Skip URL parsing for webpack internal file paths.\n  if (isWebpackFrame) {\n    str = formatFrameSourceFile(frame.file)\n  } else {\n    try {\n      const u = new URL(frame.file)\n\n      let parsedPath = ''\n      // Strip the origin for same-origin scripts.\n      if (globalThis.location?.origin !== u.origin) {\n        // URLs can be valid without an `origin`, so long as they have a\n        // `protocol`. However, `origin` is preferred.\n        if (u.origin === 'null') {\n          parsedPath += u.protocol\n        } else {\n          parsedPath += u.origin\n        }\n      }\n\n      // Strip query string information as it's typically too verbose to be\n      // meaningful.\n      parsedPath += u.pathname\n      str = formatFrameSourceFile(parsedPath)\n    } catch {\n      str = formatFrameSourceFile(frame.file)\n    }\n  }\n\n  if (!isWebpackInternalResource(frame.file) && frame.lineNumber != null) {\n    if (str) {\n      if (frame.column != null) {\n        str += ` (${frame.lineNumber}:${frame.column})`\n      } else {\n        str += ` (${frame.lineNumber})`\n      }\n    }\n  }\n  return str\n}\n"],"names":["isWebpackInternalResource","formatFrameSourceFile","getOriginalStackFrame","source","response","_getOriginalStackFrame","body","status","Promise","reject","Error","reason","value","error","external","sourceStackFrame","originalStackFrame","originalCodeFrame","sourcePackage","ignored","file","match","resolve","catch","err","message","toString","getOriginalStackFrames","frames","type","isAppDir","req","isServer","isEdgeServer","isAppDirectory","res","undefined","fetch","method","JSON","stringify","e","ok","data","json","all","map","frame","index","text","getFrameSource","isWebpackFrame","str","globalThis","u","URL","parsedPath","location","origin","protocol","pathname","lineNumber","column"],"mappings":"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"}