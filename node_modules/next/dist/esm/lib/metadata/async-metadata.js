'use client';
import { jsx as _jsx, Fragment as _Fragment } from "react/jsx-runtime";
import { Suspense, use } from 'react';
import { useServerInsertedMetadata } from '../../server/app-render/metadata-insertion/use-server-inserted-metadata';
function ServerInsertMetadata({ promise }) {
    // Apply use() to the metadata promise to suspend the rendering in SSR.
    const { metadata } = use(promise);
    // Insert metadata into the HTML stream through the `useServerInsertedMetadata`
    useServerInsertedMetadata(()=>metadata);
    return null;
}
function BrowserResolvedMetadata({ promise }) {
    const { metadata, error } = use(promise);
    // If there's metadata error on client, discard the browser metadata
    // and let metadata outlet deal with the error. This will avoid the duplication metadata.
    if (error) return null;
    return metadata;
}
export function AsyncMetadata({ promise }) {
    return /*#__PURE__*/ _jsx(_Fragment, {
        children: typeof window === 'undefined' ? /*#__PURE__*/ _jsx(ServerInsertMetadata, {
            promise: promise
        }) : /*#__PURE__*/ _jsx(BrowserResolvedMetadata, {
            promise: promise
        })
    });
}
function MetadataOutlet({ promise }) {
    const { error, digest } = use(promise);
    if (error) {
        if (digest) {
            // The error will lose its original digest after passing from server layer to client layerï¼›
            // We recover the digest property here to override the React created one if original digest exists.
            ;
            error.digest = digest;
        }
        throw error;
    }
    return null;
}
export function AsyncMetadataOutlet({ promise }) {
    return /*#__PURE__*/ _jsx(Suspense, {
        fallback: null,
        children: /*#__PURE__*/ _jsx(MetadataOutlet, {
            promise: promise
        })
    });
}

//# sourceMappingURL=async-metadata.js.map