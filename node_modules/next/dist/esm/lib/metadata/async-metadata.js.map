{"version":3,"sources":["../../../src/lib/metadata/async-metadata.tsx"],"sourcesContent":["'use client'\n\nimport { Suspense, use } from 'react'\nimport { useServerInsertedMetadata } from '../../server/app-render/metadata-insertion/use-server-inserted-metadata'\n\nexport type StreamingMetadataResolvedState = {\n  metadata: React.ReactNode\n  error: unknown | null\n  digest: string | undefined\n}\n\nfunction ServerInsertMetadata({\n  promise,\n}: {\n  promise: Promise<StreamingMetadataResolvedState>\n}) {\n  // Apply use() to the metadata promise to suspend the rendering in SSR.\n  const { metadata } = use(promise)\n  // Insert metadata into the HTML stream through the `useServerInsertedMetadata`\n  useServerInsertedMetadata(() => metadata)\n\n  return null\n}\n\nfunction BrowserResolvedMetadata({\n  promise,\n}: {\n  promise: Promise<StreamingMetadataResolvedState>\n}) {\n  const { metadata, error } = use(promise)\n  // If there's metadata error on client, discard the browser metadata\n  // and let metadata outlet deal with the error. This will avoid the duplication metadata.\n  if (error) return null\n  return metadata\n}\n\nexport function AsyncMetadata({\n  promise,\n}: {\n  promise: Promise<StreamingMetadataResolvedState>\n}) {\n  return (\n    <>\n      {typeof window === 'undefined' ? (\n        <ServerInsertMetadata promise={promise} />\n      ) : (\n        <BrowserResolvedMetadata promise={promise} />\n      )}\n    </>\n  )\n}\n\nfunction MetadataOutlet({\n  promise,\n}: {\n  promise: Promise<StreamingMetadataResolvedState>\n}) {\n  const { error, digest } = use(promise)\n  if (error) {\n    if (digest) {\n      // The error will lose its original digest after passing from server layer to client layerï¼›\n      // We recover the digest property here to override the React created one if original digest exists.\n      ;(error as any).digest = digest\n    }\n    throw error\n  }\n  return null\n}\n\nexport function AsyncMetadataOutlet({\n  promise,\n}: {\n  promise: Promise<StreamingMetadataResolvedState>\n}) {\n  return (\n    <Suspense fallback={null}>\n      <MetadataOutlet promise={promise} />\n    </Suspense>\n  )\n}\n"],"names":["Suspense","use","useServerInsertedMetadata","ServerInsertMetadata","promise","metadata","BrowserResolvedMetadata","error","AsyncMetadata","window","MetadataOutlet","digest","AsyncMetadataOutlet","fallback"],"mappings":"AAAA;;AAEA,SAASA,QAAQ,EAAEC,GAAG,QAAQ,QAAO;AACrC,SAASC,yBAAyB,QAAQ,0EAAyE;AAQnH,SAASC,qBAAqB,EAC5BC,OAAO,EAGR;IACC,uEAAuE;IACvE,MAAM,EAAEC,QAAQ,EAAE,GAAGJ,IAAIG;IACzB,+EAA+E;IAC/EF,0BAA0B,IAAMG;IAEhC,OAAO;AACT;AAEA,SAASC,wBAAwB,EAC/BF,OAAO,EAGR;IACC,MAAM,EAAEC,QAAQ,EAAEE,KAAK,EAAE,GAAGN,IAAIG;IAChC,oEAAoE;IACpE,yFAAyF;IACzF,IAAIG,OAAO,OAAO;IAClB,OAAOF;AACT;AAEA,OAAO,SAASG,cAAc,EAC5BJ,OAAO,EAGR;IACC,qBACE;kBACG,OAAOK,WAAW,4BACjB,KAACN;YAAqBC,SAASA;2BAE/B,KAACE;YAAwBF,SAASA;;;AAI1C;AAEA,SAASM,eAAe,EACtBN,OAAO,EAGR;IACC,MAAM,EAAEG,KAAK,EAAEI,MAAM,EAAE,GAAGV,IAAIG;IAC9B,IAAIG,OAAO;QACT,IAAII,QAAQ;YACV,2FAA2F;YAC3F,mGAAmG;;YACjGJ,MAAcI,MAAM,GAAGA;QAC3B;QACA,MAAMJ;IACR;IACA,OAAO;AACT;AAEA,OAAO,SAASK,oBAAoB,EAClCR,OAAO,EAGR;IACC,qBACE,KAACJ;QAASa,UAAU;kBAClB,cAAA,KAACH;YAAeN,SAASA;;;AAG/B"}