{"version":3,"sources":["../../../../src/client/components/segment-cache/cache.ts"],"sourcesContent":["import type {\n  TreePrefetch,\n  RootTreePrefetch,\n  SegmentPrefetch,\n} from '../../../server/app-render/collect-segment-data'\nimport type {\n  HeadData,\n  LoadingModuleData,\n} from '../../../shared/lib/app-router-context.shared-runtime'\nimport type {\n  CacheNodeSeedData,\n  Segment as FlightRouterStateSegment,\n} from '../../../server/app-render/types'\nimport {\n  NEXT_DID_POSTPONE_HEADER,\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n  NEXT_ROUTER_STALE_TIME_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_URL,\n  RSC_CONTENT_TYPE_HEADER,\n  RSC_HEADER,\n} from '../app-router-headers'\nimport {\n  createFetch,\n  createFromNextReadableStream,\n  urlToUrlWithoutFlightMarker,\n  type RequestHeaders,\n} from '../router-reducer/fetch-server-response'\nimport {\n  pingPrefetchTask,\n  type PrefetchTask,\n  type PrefetchSubtaskResult,\n} from './scheduler'\nimport { getAppBuildId } from '../../app-build-id'\nimport { createHrefFromUrl } from '../router-reducer/create-href-from-url'\nimport type {\n  NormalizedHref,\n  NormalizedNextUrl,\n  RouteCacheKey,\n} from './cache-key'\nimport { createTupleMap, type TupleMap, type Prefix } from './tuple-map'\nimport { createLRU } from './lru'\nimport {\n  encodeChildSegmentKey,\n  encodeSegment,\n  ROOT_SEGMENT_KEY,\n} from '../../../server/app-render/segment-value-encoding'\nimport type {\n  FlightRouterState,\n  NavigationFlightResponse,\n} from '../../../server/app-render/types'\nimport { normalizeFlightData } from '../../flight-data-helpers'\nimport { STATIC_STALETIME_MS } from '../router-reducer/prefetch-cache-utils'\nimport { pingVisibleLinks } from '../../app-dir/link'\n\n// A note on async/await when working in the prefetch cache:\n//\n// Most async operations in the prefetch cache should *not* use async/await,\n// Instead, spawn a subtask that writes the results to a cache entry, and attach\n// a \"ping\" listener to notify the prefetch queue to try again.\n//\n// The reason is we need to be able to access the segment cache and traverse its\n// data structures synchronously. For example, if there's a synchronous update\n// we can take an immediate snapshot of the cache to produce something we can\n// render. Limiting the use of async/await also makes it easier to avoid race\n// conditions, which is especially important because is cache is mutable.\n//\n// Another reason is that while we're performing async work, it's possible for\n// existing entries to become stale, or for Link prefetches to be removed from\n// the queue. For optimal scheduling, we need to be able to \"cancel\" subtasks\n// that are no longer needed. So, when a segment is received from the server, we\n// restart from the root of the tree that's being prefetched, to confirm all the\n// parent segments are still cached. If the segment is no longer reachable from\n// the root, then it's effectively canceled. This is similar to the design of\n// Rust Futures, or React Suspense.\n\nexport type RouteTree = {\n  key: string\n  segment: FlightRouterStateSegment\n  slots: null | {\n    [parallelRouteKey: string]: RouteTree\n  }\n  isRootLayout: boolean\n}\n\ntype RouteCacheEntryShared = {\n  staleAt: number\n  // This is false only if we're certain the route cannot be intercepted. It's\n  // true in all other cases, including on initialization when we haven't yet\n  // received a response from the server.\n  couldBeIntercepted: boolean\n\n  // LRU-related fields\n  keypath: null | Prefix<RouteCacheKeypath>\n  next: null | RouteCacheEntry\n  prev: null | RouteCacheEntry\n  size: number\n}\n\n/**\n * Tracks the status of a cache entry as it progresses from no data (Empty),\n * waiting for server data (Pending), and finished (either Fulfilled or\n * Rejected depending on the response from the server.\n */\nexport const enum EntryStatus {\n  Empty,\n  Pending,\n  Fulfilled,\n  Rejected,\n}\n\ntype PendingRouteCacheEntry = RouteCacheEntryShared & {\n  status: EntryStatus.Empty | EntryStatus.Pending\n  blockedTasks: Set<PrefetchTask> | null\n  canonicalUrl: null\n  tree: null\n  head: HeadData | null\n  isHeadPartial: true\n  isPPREnabled: false\n}\n\ntype RejectedRouteCacheEntry = RouteCacheEntryShared & {\n  status: EntryStatus.Rejected\n  blockedTasks: Set<PrefetchTask> | null\n  canonicalUrl: null\n  tree: null\n  head: null\n  isHeadPartial: true\n  isPPREnabled: boolean\n}\n\nexport type FulfilledRouteCacheEntry = RouteCacheEntryShared & {\n  status: EntryStatus.Fulfilled\n  blockedTasks: null\n  canonicalUrl: string\n  tree: RouteTree\n  head: HeadData\n  isHeadPartial: boolean\n  isPPREnabled: boolean\n}\n\nexport type RouteCacheEntry =\n  | PendingRouteCacheEntry\n  | FulfilledRouteCacheEntry\n  | RejectedRouteCacheEntry\n\nexport const enum FetchStrategy {\n  PPR,\n  Full,\n  LoadingBoundary,\n}\n\ntype SegmentCacheEntryShared = {\n  staleAt: number\n  fetchStrategy: FetchStrategy\n  revalidating: SegmentCacheEntry | null\n\n  // LRU-related fields\n  key: null | string\n  next: null | RouteCacheEntry\n  prev: null | RouteCacheEntry\n  size: number\n}\n\nexport type EmptySegmentCacheEntry = SegmentCacheEntryShared & {\n  status: EntryStatus.Empty\n  rsc: null\n  loading: null\n  isPartial: true\n  promise: null\n}\n\nexport type PendingSegmentCacheEntry = SegmentCacheEntryShared & {\n  status: EntryStatus.Pending\n  rsc: null\n  loading: null\n  isPartial: true\n  promise: null | PromiseWithResolvers<FulfilledSegmentCacheEntry | null>\n}\n\ntype RejectedSegmentCacheEntry = SegmentCacheEntryShared & {\n  status: EntryStatus.Rejected\n  rsc: null\n  loading: null\n  isPartial: true\n  promise: null\n}\n\nexport type FulfilledSegmentCacheEntry = SegmentCacheEntryShared & {\n  status: EntryStatus.Fulfilled\n  rsc: React.ReactNode | null\n  loading: LoadingModuleData | Promise<LoadingModuleData>\n  isPartial: boolean\n  promise: null\n}\n\nexport type SegmentCacheEntry =\n  | EmptySegmentCacheEntry\n  | PendingSegmentCacheEntry\n  | RejectedSegmentCacheEntry\n  | FulfilledSegmentCacheEntry\n\nexport type NonEmptySegmentCacheEntry = Exclude<\n  SegmentCacheEntry,\n  EmptySegmentCacheEntry\n>\n\n// Route cache entries vary on multiple keys: the href and the Next-Url. Each of\n// these parts needs to be included in the internal cache key. Rather than\n// concatenate the keys into a single key, we use a multi-level map, where the\n// first level is keyed by href, the second level is keyed by Next-Url, and so\n// on (if were to add more levels).\ntype RouteCacheKeypath = [NormalizedHref, NormalizedNextUrl]\nlet routeCacheMap: TupleMap<RouteCacheKeypath, RouteCacheEntry> =\n  createTupleMap()\n\n// We use an LRU for memory management. We must update this whenever we add or\n// remove a new cache entry, or when an entry changes size.\n// TODO: I chose the max size somewhat arbitrarily. Consider setting this based\n// on navigator.deviceMemory, or some other heuristic. We should make this\n// customizable via the Next.js config, too.\nconst maxRouteLruSize = 10 * 1024 * 1024 // 10 MB\nlet routeCacheLru = createLRU<RouteCacheEntry>(\n  maxRouteLruSize,\n  onRouteLRUEviction\n)\n\n// TODO: We may eventually store segment entries in a tuple map, too, to\n// account for search params.\nlet segmentCacheMap = new Map<string, SegmentCacheEntry>()\n// NOTE: Segments and Route entries are managed by separate LRUs. We could\n// combine them into a single LRU, but because they are separate types, we'd\n// need to wrap each one in an extra LRU node (to maintain monomorphism, at the\n// cost of additional memory).\nconst maxSegmentLruSize = 50 * 1024 * 1024 // 50 MB\nlet segmentCacheLru = createLRU<SegmentCacheEntry>(\n  maxSegmentLruSize,\n  onSegmentLRUEviction\n)\n\n// Incrementing counter used to track cache invalidations.\nlet currentCacheVersion = 0\n\nexport function getCurrentCacheVersion(): number {\n  return currentCacheVersion\n}\n\n/**\n * Used to clear the client prefetch cache when a server action calls\n * revalidatePath or revalidateTag. Eventually we will support only clearing the\n * segments that were actually affected, but there's more work to be done on the\n * server before the client is able to do this correctly.\n */\nexport function revalidateEntireCache(\n  nextUrl: string | null,\n  tree: FlightRouterState\n) {\n  currentCacheVersion++\n\n  // Clearing the cache also effectively rejects any pending requests, because\n  // when the response is received, it gets written into a cache entry that is\n  // no longer reachable.\n  // TODO: There's an exception to this case that we don't currently handle\n  // correctly: background revalidations. See note in `upsertSegmentEntry`.\n  routeCacheMap = createTupleMap()\n  routeCacheLru = createLRU(maxRouteLruSize, onRouteLRUEviction)\n  segmentCacheMap = new Map()\n  segmentCacheLru = createLRU(maxSegmentLruSize, onSegmentLRUEviction)\n\n  // Prefetch all the currently visible links again, to re-fill the cache.\n  pingVisibleLinks(nextUrl, tree)\n}\n\nexport function readExactRouteCacheEntry(\n  now: number,\n  href: NormalizedHref,\n  nextUrl: NormalizedNextUrl | null\n): RouteCacheEntry | null {\n  const keypath: Prefix<RouteCacheKeypath> =\n    nextUrl === null ? [href] : [href, nextUrl]\n  const existingEntry = routeCacheMap.get(keypath)\n  if (existingEntry !== null) {\n    // Check if the entry is stale\n    if (existingEntry.staleAt > now) {\n      // Reuse the existing entry.\n\n      // Since this is an access, move the entry to the front of the LRU.\n      routeCacheLru.put(existingEntry)\n\n      return existingEntry\n    } else {\n      // Evict the stale entry from the cache.\n      deleteRouteFromCache(existingEntry, keypath)\n    }\n  }\n  return null\n}\n\nexport function readRouteCacheEntry(\n  now: number,\n  key: RouteCacheKey\n): RouteCacheEntry | null {\n  // First check if there's a non-intercepted entry. Most routes cannot be\n  // intercepted, so this is the common case.\n  const nonInterceptedEntry = readExactRouteCacheEntry(now, key.href, null)\n  if (nonInterceptedEntry !== null && !nonInterceptedEntry.couldBeIntercepted) {\n    // Found a match, and the route cannot be intercepted. We can reuse it.\n    return nonInterceptedEntry\n  }\n  // There was no match. Check again but include the Next-Url this time.\n  return readExactRouteCacheEntry(now, key.href, key.nextUrl)\n}\n\nexport function readSegmentCacheEntry(\n  now: number,\n  path: string\n): SegmentCacheEntry | null {\n  const existingEntry = segmentCacheMap.get(path)\n  if (existingEntry !== undefined) {\n    // Check if the entry is stale\n    if (existingEntry.staleAt > now) {\n      // Reuse the existing entry.\n\n      // Since this is an access, move the entry to the front of the LRU.\n      segmentCacheLru.put(existingEntry)\n\n      return existingEntry\n    } else {\n      // This is a stale entry.\n      const revalidatingEntry = existingEntry.revalidating\n      if (revalidatingEntry !== null) {\n        // There's a revalidation in progress. Upsert it.\n        const upsertedEntry = upsertSegmentEntry(now, path, revalidatingEntry)\n        if (upsertedEntry !== null && upsertedEntry.staleAt > now) {\n          // We can use the upserted revalidation entry.\n          return upsertedEntry\n        }\n      } else {\n        // Evict the stale entry from the cache.\n        deleteSegmentFromCache(existingEntry, path)\n      }\n    }\n  }\n  return null\n}\n\nfunction readRevalidatingSegmentCacheEntry(\n  now: number,\n  owner: SegmentCacheEntry\n): SegmentCacheEntry | null {\n  const existingRevalidation = owner.revalidating\n  if (existingRevalidation !== null) {\n    if (existingRevalidation.staleAt > now) {\n      // There's already a revalidation in progress. Or a previous revalidation\n      // failed and it has not yet expired.\n      return existingRevalidation\n    } else {\n      // Clear the stale revalidation from its owner.\n      clearRevalidatingSegmentFromOwner(owner)\n    }\n  }\n  return null\n}\n\nexport function waitForSegmentCacheEntry(\n  pendingEntry: PendingSegmentCacheEntry\n): Promise<FulfilledSegmentCacheEntry | null> {\n  // Because the entry is pending, there's already a in-progress request.\n  // Attach a promise to the entry that will resolve when the server responds.\n  let promiseWithResolvers = pendingEntry.promise\n  if (promiseWithResolvers === null) {\n    promiseWithResolvers = pendingEntry.promise =\n      createPromiseWithResolvers<FulfilledSegmentCacheEntry | null>()\n  } else {\n    // There's already a promise we can use\n  }\n  return promiseWithResolvers.promise\n}\n\n/**\n * Checks if an entry for a route exists in the cache. If so, it returns the\n * entry, If not, it adds an empty entry to the cache and returns it.\n */\nexport function readOrCreateRouteCacheEntry(\n  now: number,\n  task: PrefetchTask\n): RouteCacheEntry {\n  const key = task.key\n  const existingEntry = readRouteCacheEntry(now, key)\n  if (existingEntry !== null) {\n    return existingEntry\n  }\n  // Create a pending entry and add it to the cache.\n  const pendingEntry: PendingRouteCacheEntry = {\n    canonicalUrl: null,\n    status: EntryStatus.Empty,\n    blockedTasks: null,\n    tree: null,\n    head: null,\n    isHeadPartial: true,\n    // Since this is an empty entry, there's no reason to ever evict it. It will\n    // be updated when the data is populated.\n    staleAt: Infinity,\n    // This is initialized to true because we don't know yet whether the route\n    // could be intercepted. It's only set to false once we receive a response\n    // from the server.\n    couldBeIntercepted: true,\n    // Similarly, we don't yet know if the route supports PPR.\n    isPPREnabled: false,\n\n    // LRU-related fields\n    keypath: null,\n    next: null,\n    prev: null,\n    size: 0,\n  }\n  const keypath: Prefix<RouteCacheKeypath> =\n    key.nextUrl === null ? [key.href] : [key.href, key.nextUrl]\n  routeCacheMap.set(keypath, pendingEntry)\n  // Stash the keypath on the entry so we know how to remove it from the map\n  // if it gets evicted from the LRU.\n  pendingEntry.keypath = keypath\n  routeCacheLru.put(pendingEntry)\n  return pendingEntry\n}\n\n/**\n * Checks if an entry for a segment exists in the cache. If so, it returns the\n * entry, If not, it adds an empty entry to the cache and returns it.\n */\nexport function readOrCreateSegmentCacheEntry(\n  now: number,\n  // TODO: Don't need to pass the whole route. Just `staleAt`.\n  route: FulfilledRouteCacheEntry,\n  path: string\n): SegmentCacheEntry {\n  const existingEntry = readSegmentCacheEntry(now, path)\n  if (existingEntry !== null) {\n    return existingEntry\n  }\n  // Create a pending entry and add it to the cache.\n  const pendingEntry = createDetachedSegmentCacheEntry(route.staleAt)\n  segmentCacheMap.set(path, pendingEntry)\n  // Stash the keypath on the entry so we know how to remove it from the map\n  // if it gets evicted from the LRU.\n  pendingEntry.key = path\n  segmentCacheLru.put(pendingEntry)\n  return pendingEntry\n}\n\nexport function readOrCreateRevalidatingSegmentEntry(\n  now: number,\n  prevEntry: SegmentCacheEntry\n): SegmentCacheEntry {\n  const existingRevalidation = readRevalidatingSegmentCacheEntry(now, prevEntry)\n  if (existingRevalidation !== null) {\n    return existingRevalidation\n  }\n  const pendingEntry = createDetachedSegmentCacheEntry(prevEntry.staleAt)\n\n  // Background revalidations are not stored directly in the cache map or LRU;\n  // they're stashed on the entry that they will (potentially) replace.\n  //\n  // Note that we don't actually ever clear this field, except when the entry\n  // expires. When the revalidation finishes, one of two things will happen:\n  //\n  //  1) the revalidation is successful, `prevEntry` is removed from the cache\n  //     and garbage collected (so there's no point clearing any of its fields)\n  //  2) the revalidation fails, and we'll use the `revalidating` field to\n  //     prevent subsequent revalidation attempts, until it expires.\n  prevEntry.revalidating = pendingEntry\n\n  return pendingEntry\n}\n\nexport function upsertSegmentEntry(\n  now: number,\n  segmentKeyPath: string,\n  candidateEntry: SegmentCacheEntry\n): SegmentCacheEntry | null {\n  // We have a new entry that has not yet been inserted into the cache. Before\n  // we do so, we need to confirm whether it takes precedence over the existing\n  // entry (if one exists).\n  // TODO: We should not upsert an entry if its key was invalidated in the time\n  // since the request was made. We can do that by passing the \"owner\" entry to\n  // this function and confirming it's the same as `existingEntry`.\n  const existingEntry = readSegmentCacheEntry(now, segmentKeyPath)\n  if (existingEntry !== null) {\n    if (candidateEntry.isPartial && !existingEntry.isPartial) {\n      // Don't replace a full segment with a partial one. A case where this\n      // might happen is if the existing segment was fetched via\n      // <Link prefetch={true}>.\n\n      // We're going to leave the entry on the owner's `revalidating` field\n      // so that it doesn't get revalidated again unnecessarily. Downgrade the\n      // Fulfilled entry to Rejected and null out the data so it can be garbage\n      // collected. We leave `staleAt` intact to prevent subsequent revalidation\n      // attempts only until the entry expires.\n      const rejectedEntry: RejectedSegmentCacheEntry = candidateEntry as any\n      rejectedEntry.status = EntryStatus.Rejected\n      rejectedEntry.loading = null\n      rejectedEntry.rsc = null\n      return null\n    }\n    // Evict the existing entry from the cache.\n    deleteSegmentFromCache(existingEntry, segmentKeyPath)\n  }\n  segmentCacheMap.set(segmentKeyPath, candidateEntry)\n  // Stash the keypath on the entry so we know how to remove it from the map\n  // if it gets evicted from the LRU.\n  candidateEntry.key = segmentKeyPath\n  segmentCacheLru.put(candidateEntry)\n  return candidateEntry\n}\n\nexport function createDetachedSegmentCacheEntry(\n  staleAt: number\n): EmptySegmentCacheEntry {\n  const emptyEntry: EmptySegmentCacheEntry = {\n    status: EntryStatus.Empty,\n    // Default to assuming the fetch strategy will be PPR. This will be updated\n    // when a fetch is actually initiated.\n    fetchStrategy: FetchStrategy.PPR,\n    revalidating: null,\n    rsc: null,\n    loading: null,\n    staleAt,\n    isPartial: true,\n    promise: null,\n\n    // LRU-related fields\n    key: null,\n    next: null,\n    prev: null,\n    size: 0,\n  }\n  return emptyEntry\n}\n\nexport function upgradeToPendingSegment(\n  emptyEntry: EmptySegmentCacheEntry,\n  fetchStrategy: FetchStrategy\n): PendingSegmentCacheEntry {\n  const pendingEntry: PendingSegmentCacheEntry = emptyEntry as any\n  pendingEntry.status = EntryStatus.Pending\n  pendingEntry.fetchStrategy = fetchStrategy\n  return pendingEntry\n}\n\nfunction deleteRouteFromCache(\n  entry: RouteCacheEntry,\n  keypath: Prefix<RouteCacheKeypath>\n): void {\n  pingBlockedTasks(entry)\n  routeCacheMap.delete(keypath)\n  routeCacheLru.delete(entry)\n}\n\nfunction deleteSegmentFromCache(entry: SegmentCacheEntry, key: string): void {\n  cancelEntryListeners(entry)\n  segmentCacheMap.delete(key)\n  segmentCacheLru.delete(entry)\n  clearRevalidatingSegmentFromOwner(entry)\n}\n\nfunction clearRevalidatingSegmentFromOwner(owner: SegmentCacheEntry): void {\n  // Revalidating segments are not stored in the cache directly; they're\n  // stored as a field on the entry that they will (potentially) replace. So\n  // to dispose of an existing revalidation, we just need to null out the field\n  // on the owner.\n  const revalidatingSegment = owner.revalidating\n  if (revalidatingSegment !== null) {\n    cancelEntryListeners(revalidatingSegment)\n    owner.revalidating = null\n  }\n}\n\nexport function resetRevalidatingSegmentEntry(\n  owner: SegmentCacheEntry\n): EmptySegmentCacheEntry {\n  clearRevalidatingSegmentFromOwner(owner)\n  const emptyEntry = createDetachedSegmentCacheEntry(owner.staleAt)\n  owner.revalidating = emptyEntry\n  return emptyEntry\n}\n\nfunction onRouteLRUEviction(entry: RouteCacheEntry): void {\n  // The LRU evicted this entry. Remove it from the map.\n  const keypath = entry.keypath\n  if (keypath !== null) {\n    entry.keypath = null\n    pingBlockedTasks(entry)\n    routeCacheMap.delete(keypath)\n  }\n}\n\nfunction onSegmentLRUEviction(entry: SegmentCacheEntry): void {\n  // The LRU evicted this entry. Remove it from the map.\n  const key = entry.key\n  if (key !== null) {\n    entry.key = null\n    cancelEntryListeners(entry)\n    segmentCacheMap.delete(key)\n  }\n}\n\nfunction cancelEntryListeners(entry: SegmentCacheEntry): void {\n  if (entry.status === EntryStatus.Pending && entry.promise !== null) {\n    // There were listeners for this entry. Resolve them with `null` to indicate\n    // that the prefetch failed. It's up to the listener to decide how to handle\n    // this case.\n    // NOTE: We don't currently propagate the reason the prefetch was canceled\n    // but we could by accepting a `reason` argument.\n    entry.promise.resolve(null)\n    entry.promise = null\n  }\n}\n\nfunction pingBlockedTasks(entry: {\n  blockedTasks: Set<PrefetchTask> | null\n}): void {\n  const blockedTasks = entry.blockedTasks\n  if (blockedTasks !== null) {\n    for (const task of blockedTasks) {\n      pingPrefetchTask(task)\n    }\n    entry.blockedTasks = null\n  }\n}\n\nfunction fulfillRouteCacheEntry(\n  entry: RouteCacheEntry,\n  tree: RouteTree,\n  head: HeadData,\n  isHeadPartial: boolean,\n  staleAt: number,\n  couldBeIntercepted: boolean,\n  canonicalUrl: string,\n  isPPREnabled: boolean\n): FulfilledRouteCacheEntry {\n  const fulfilledEntry: FulfilledRouteCacheEntry = entry as any\n  fulfilledEntry.status = EntryStatus.Fulfilled\n  fulfilledEntry.tree = tree\n  fulfilledEntry.head = head\n  fulfilledEntry.isHeadPartial = isHeadPartial\n  fulfilledEntry.staleAt = staleAt\n  fulfilledEntry.couldBeIntercepted = couldBeIntercepted\n  fulfilledEntry.canonicalUrl = canonicalUrl\n  fulfilledEntry.isPPREnabled = isPPREnabled\n  pingBlockedTasks(entry)\n  return fulfilledEntry\n}\n\nfunction fulfillSegmentCacheEntry(\n  segmentCacheEntry: EmptySegmentCacheEntry | PendingSegmentCacheEntry,\n  rsc: React.ReactNode,\n  loading: LoadingModuleData | Promise<LoadingModuleData>,\n  staleAt: number,\n  isPartial: boolean\n): FulfilledSegmentCacheEntry {\n  const fulfilledEntry: FulfilledSegmentCacheEntry = segmentCacheEntry as any\n  fulfilledEntry.status = EntryStatus.Fulfilled\n  fulfilledEntry.rsc = rsc\n  fulfilledEntry.loading = loading\n  fulfilledEntry.staleAt = staleAt\n  fulfilledEntry.isPartial = isPartial\n  // Resolve any listeners that were waiting for this data.\n  if (segmentCacheEntry.promise !== null) {\n    segmentCacheEntry.promise.resolve(fulfilledEntry)\n    // Free the promise for garbage collection.\n    fulfilledEntry.promise = null\n  }\n  return fulfilledEntry\n}\n\nfunction rejectRouteCacheEntry(\n  entry: PendingRouteCacheEntry,\n  staleAt: number\n): void {\n  const rejectedEntry: RejectedRouteCacheEntry = entry as any\n  rejectedEntry.status = EntryStatus.Rejected\n  rejectedEntry.staleAt = staleAt\n  pingBlockedTasks(entry)\n}\n\nfunction rejectSegmentCacheEntry(\n  entry: PendingSegmentCacheEntry,\n  staleAt: number\n): void {\n  const rejectedEntry: RejectedSegmentCacheEntry = entry as any\n  rejectedEntry.status = EntryStatus.Rejected\n  rejectedEntry.staleAt = staleAt\n  if (entry.promise !== null) {\n    // NOTE: We don't currently propagate the reason the prefetch was canceled\n    // but we could by accepting a `reason` argument.\n    entry.promise.resolve(null)\n    entry.promise = null\n  }\n}\n\nfunction convertRootTreePrefetchToRouteTree(rootTree: RootTreePrefetch) {\n  return convertTreePrefetchToRouteTree(rootTree.tree, ROOT_SEGMENT_KEY)\n}\n\nfunction convertTreePrefetchToRouteTree(\n  prefetch: TreePrefetch,\n  key: string\n): RouteTree {\n  // Converts the route tree sent by the server into the format used by the\n  // cache. The cached version of the tree includes additional fields, such as a\n  // cache key for each segment. Since this is frequently accessed, we compute\n  // it once instead of on every access. This same cache key is also used to\n  // request the segment from the server.\n  let slots: { [parallelRouteKey: string]: RouteTree } | null = null\n  const prefetchSlots = prefetch.slots\n  if (prefetchSlots !== null) {\n    slots = {}\n    for (let parallelRouteKey in prefetchSlots) {\n      const childPrefetch = prefetchSlots[parallelRouteKey]\n      const childSegment = childPrefetch.segment\n      // TODO: Eventually, the param values will not be included in the response\n      // from the server. We'll instead fill them in on the client by parsing\n      // the URL. This is where we'll do that.\n      const childKey = encodeChildSegmentKey(\n        key,\n        parallelRouteKey,\n        encodeSegment(childSegment)\n      )\n      slots[parallelRouteKey] = convertTreePrefetchToRouteTree(\n        childPrefetch,\n        childKey\n      )\n    }\n  }\n  return {\n    key,\n    segment: prefetch.segment,\n    slots,\n    isRootLayout: prefetch.isRootLayout,\n  }\n}\n\nfunction convertRootFlightRouterStateToRouteTree(\n  flightRouterState: FlightRouterState\n): RouteTree {\n  return convertFlightRouterStateToRouteTree(\n    flightRouterState,\n    ROOT_SEGMENT_KEY\n  )\n}\n\nfunction convertFlightRouterStateToRouteTree(\n  flightRouterState: FlightRouterState,\n  key: string\n): RouteTree {\n  let slots: { [parallelRouteKey: string]: RouteTree } | null = null\n\n  const parallelRoutes = flightRouterState[1]\n  for (let parallelRouteKey in parallelRoutes) {\n    const childRouterState = parallelRoutes[parallelRouteKey]\n    const childSegment = childRouterState[0]\n    // TODO: Eventually, the param values will not be included in the response\n    // from the server. We'll instead fill them in on the client by parsing\n    // the URL. This is where we'll do that.\n    const childKey = encodeChildSegmentKey(\n      key,\n      parallelRouteKey,\n      encodeSegment(childSegment)\n    )\n    const childTree = convertFlightRouterStateToRouteTree(\n      childRouterState,\n      childKey\n    )\n    if (slots === null) {\n      slots = {\n        [parallelRouteKey]: childTree,\n      }\n    } else {\n      slots[parallelRouteKey] = childTree\n    }\n  }\n\n  return {\n    key,\n    segment: flightRouterState[0],\n    slots,\n    isRootLayout: flightRouterState[4] === true,\n  }\n}\n\nexport function convertRouteTreeToFlightRouterState(\n  routeTree: RouteTree\n): FlightRouterState {\n  const parallelRoutes: Record<string, FlightRouterState> = {}\n  if (routeTree.slots !== null) {\n    for (const parallelRouteKey in routeTree.slots) {\n      parallelRoutes[parallelRouteKey] = convertRouteTreeToFlightRouterState(\n        routeTree.slots[parallelRouteKey]\n      )\n    }\n  }\n  const flightRouterState: FlightRouterState = [\n    routeTree.segment,\n    parallelRoutes,\n    null,\n    null,\n    routeTree.isRootLayout,\n  ]\n  return flightRouterState\n}\n\nexport async function fetchRouteOnCacheMiss(\n  entry: PendingRouteCacheEntry,\n  task: PrefetchTask\n): Promise<PrefetchSubtaskResult<null> | null> {\n  // This function is allowed to use async/await because it contains the actual\n  // fetch that gets issued on a cache miss. Notice it writes the result to the\n  // cache entry directly, rather than return data that is then written by\n  // the caller.\n  const key = task.key\n  const href = key.href\n  const nextUrl = key.nextUrl\n  try {\n    const response = await fetchSegmentPrefetchResponse(href, '/_tree', nextUrl)\n    if (\n      !response ||\n      !response.ok ||\n      // 204 is a Cache miss. Though theoretically this shouldn't happen when\n      // PPR is enabled, because we always respond to route tree requests, even\n      // if it needs to be blockingly generated on demand.\n      response.status === 204 ||\n      !response.body\n    ) {\n      // Server responded with an error, or with a miss. We should still cache\n      // the response, but we can try again after 10 seconds.\n      rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n      return null\n    }\n\n    // This is a bit convoluted but it's taken from router-reducer and\n    // fetch-server-response\n    const canonicalUrl = response.redirected\n      ? createHrefFromUrl(urlToUrlWithoutFlightMarker(response.url))\n      : href\n\n    // Check whether the response varies based on the Next-Url header.\n    const varyHeader = response.headers.get('vary')\n    const couldBeIntercepted =\n      varyHeader !== null && varyHeader.includes(NEXT_URL)\n\n    // Track when the network connection closes.\n    const closed = createPromiseWithResolvers<void>()\n\n    // This checks whether the response was served from the per-segment cache,\n    // rather than the old prefetching flow. If it fails, it implies that PPR\n    // is disabled on this route.\n    // TODO: Add support for non-PPR routes.\n    const routeIsPPREnabled =\n      response.headers.get(NEXT_DID_POSTPONE_HEADER) === '2'\n    if (routeIsPPREnabled) {\n      const prefetchStream = createPrefetchResponseStream(\n        response.body,\n        closed.resolve,\n        function onResponseSizeUpdate(size) {\n          routeCacheLru.updateSize(entry, size)\n        }\n      )\n      const serverData = await (createFromNextReadableStream(\n        prefetchStream\n      ) as Promise<RootTreePrefetch>)\n      if (serverData.buildId !== getAppBuildId()) {\n        // The server build does not match the client. Treat as a 404. During\n        // an actual navigation, the router will trigger an MPA navigation.\n        // TODO: Consider moving the build ID to a response header so we can check\n        // it before decoding the response, and so there's one way of checking\n        // across all response types.\n        rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n        return null\n      }\n\n      const staleTimeMs = serverData.staleTime * 1000\n      fulfillRouteCacheEntry(\n        entry,\n        convertRootTreePrefetchToRouteTree(serverData),\n        serverData.head,\n        serverData.isHeadPartial,\n        Date.now() + staleTimeMs,\n        couldBeIntercepted,\n        canonicalUrl,\n        routeIsPPREnabled\n      )\n    } else {\n      // PPR is not enabled for this route. The server responds with a\n      // different format (FlightRouterState) that we need to convert.\n      // TODO: We will unify the responses eventually. I'm keeping the types\n      // separate for now because FlightRouterState has so many\n      // overloaded concerns.\n      const prefetchStream = createPrefetchResponseStream(\n        response.body,\n        closed.resolve,\n        function onResponseSizeUpdate(size) {\n          routeCacheLru.updateSize(entry, size)\n        }\n      )\n      const serverData = await (createFromNextReadableStream(\n        prefetchStream\n      ) as Promise<NavigationFlightResponse>)\n\n      writeDynamicTreeResponseIntoCache(\n        Date.now(),\n        response,\n        serverData,\n        entry,\n        couldBeIntercepted,\n        canonicalUrl,\n        routeIsPPREnabled\n      )\n    }\n\n    if (!couldBeIntercepted && nextUrl !== null) {\n      // This route will never be intercepted. So we can use this entry for all\n      // requests to this route, regardless of the Next-Url header. This works\n      // because when reading the cache we always check for a valid\n      // non-intercepted entry first.\n      //\n      // Re-key the entry. Since we're in an async task, we must first confirm\n      // that the entry hasn't been concurrently modified by a different task.\n      const currentKeypath: Prefix<RouteCacheKeypath> = [href, nextUrl]\n      const expectedEntry = routeCacheMap.get(currentKeypath)\n      if (expectedEntry === entry) {\n        routeCacheMap.delete(currentKeypath)\n        const newKeypath: Prefix<RouteCacheKeypath> = [href]\n        routeCacheMap.set(newKeypath, entry)\n        // We don't need to update the LRU because the entry is already in it.\n        // But since we changed the keypath, we do need to update that, so we\n        // know how to remove it from the map if it gets evicted from the LRU.\n        entry.keypath = newKeypath\n      } else {\n        // Something else modified this entry already. Since the re-keying is\n        // just a performance optimization, we can safely skip it.\n      }\n    }\n    // Return a promise that resolves when the network connection closes, so\n    // the scheduler can track the number of concurrent network connections.\n    return { value: null, closed: closed.promise }\n  } catch (error) {\n    // Either the connection itself failed, or something bad happened while\n    // decoding the response.\n    rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n    return null\n  }\n}\n\nexport async function fetchSegmentOnCacheMiss(\n  route: FulfilledRouteCacheEntry,\n  segmentCacheEntry: PendingSegmentCacheEntry,\n  routeKey: RouteCacheKey,\n  segmentKeyPath: string\n): Promise<PrefetchSubtaskResult<FulfilledSegmentCacheEntry> | null> {\n  // This function is allowed to use async/await because it contains the actual\n  // fetch that gets issued on a cache miss. Notice it writes the result to the\n  // cache entry directly, rather than return data that is then written by\n  // the caller.\n  //\n  // Segment fetches are non-blocking so we don't need to ping the scheduler\n  // on completion.\n  const href = routeKey.href\n  try {\n    const response = await fetchSegmentPrefetchResponse(\n      href,\n      segmentKeyPath === ROOT_SEGMENT_KEY\n        ? // The root segment is a special case. To simplify the server-side\n          // handling of these requests, we encode the root segment path as\n          // `_index` instead of as an empty string. This should be treated as\n          // an implementation detail and not as a stable part of the protocol.\n          // It just needs to match the equivalent logic that happens when\n          // prerendering the responses. It should not leak outside of Next.js.\n          '/_index'\n        : segmentKeyPath,\n      routeKey.nextUrl\n    )\n    if (\n      !response ||\n      !response.ok ||\n      response.status === 204 || // Cache miss\n      // This checks whether the response was served from the per-segment cache,\n      // rather than the old prefetching flow. If it fails, it implies that PPR\n      // is disabled on this route. Theoretically this should never happen\n      // because we only issue requests for segments once we've verified that\n      // the route supports PPR.\n      response.headers.get(NEXT_DID_POSTPONE_HEADER) !== '2' ||\n      !response.body\n    ) {\n      // Server responded with an error, or with a miss. We should still cache\n      // the response, but we can try again after 10 seconds.\n      rejectSegmentCacheEntry(segmentCacheEntry, Date.now() + 10 * 1000)\n      return null\n    }\n\n    // Track when the network connection closes.\n    const closed = createPromiseWithResolvers<void>()\n\n    // Wrap the original stream in a new stream that never closes. That way the\n    // Flight client doesn't error if there's a hanging promise.\n    const prefetchStream = createPrefetchResponseStream(\n      response.body,\n      closed.resolve,\n      function onResponseSizeUpdate(size) {\n        segmentCacheLru.updateSize(segmentCacheEntry, size)\n      }\n    )\n    const serverData = await (createFromNextReadableStream(\n      prefetchStream\n    ) as Promise<SegmentPrefetch>)\n    if (serverData.buildId !== getAppBuildId()) {\n      // The server build does not match the client. Treat as a 404. During\n      // an actual navigation, the router will trigger an MPA navigation.\n      // TODO: Consider moving the build ID to a response header so we can check\n      // it before decoding the response, and so there's one way of checking\n      // across all response types.\n      rejectSegmentCacheEntry(segmentCacheEntry, Date.now() + 10 * 1000)\n      return null\n    }\n    return {\n      value: fulfillSegmentCacheEntry(\n        segmentCacheEntry,\n        serverData.rsc,\n        serverData.loading,\n        // TODO: The server does not currently provide per-segment stale time.\n        // So we use the stale time of the route.\n        route.staleAt,\n        serverData.isPartial\n      ),\n      // Return a promise that resolves when the network connection closes, so\n      // the scheduler can track the number of concurrent network connections.\n      closed: closed.promise,\n    }\n  } catch (error) {\n    // Either the connection itself failed, or something bad happened while\n    // decoding the response.\n    rejectSegmentCacheEntry(segmentCacheEntry, Date.now() + 10 * 1000)\n    return null\n  }\n}\n\nexport async function fetchSegmentPrefetchesUsingDynamicRequest(\n  task: PrefetchTask,\n  route: FulfilledRouteCacheEntry,\n  fetchStrategy: FetchStrategy,\n  dynamicRequestTree: FlightRouterState,\n  spawnedEntries: Map<string, PendingSegmentCacheEntry>\n): Promise<PrefetchSubtaskResult<null> | null> {\n  const href = task.key.href\n  const nextUrl = task.key.nextUrl\n  const headers: RequestHeaders = {\n    [RSC_HEADER]: '1',\n    [NEXT_ROUTER_STATE_TREE_HEADER]: encodeURIComponent(\n      JSON.stringify(dynamicRequestTree)\n    ),\n  }\n  if (nextUrl !== null) {\n    headers[NEXT_URL] = nextUrl\n  }\n  // Only set the prefetch header if we're not doing a \"full\" prefetch. We\n  // omit the prefetch header from a full prefetch because it's essentially\n  // just a navigation request that happens ahead of time — it should include\n  // all the same data in the response.\n  if (fetchStrategy !== FetchStrategy.Full) {\n    headers[NEXT_ROUTER_PREFETCH_HEADER] = '1'\n  }\n  try {\n    const response = await fetchPrefetchResponse(href, headers)\n    if (!response || !response.ok || !response.body) {\n      // Server responded with an error, or with a miss. We should still cache\n      // the response, but we can try again after 10 seconds.\n      rejectSegmentEntriesIfStillPending(spawnedEntries, Date.now() + 10 * 1000)\n      return null\n    }\n\n    // Track when the network connection closes.\n    const closed = createPromiseWithResolvers<void>()\n\n    let fulfilledEntries: Array<FulfilledSegmentCacheEntry> | null = null\n    const prefetchStream = createPrefetchResponseStream(\n      response.body,\n      closed.resolve,\n      function onResponseSizeUpdate(totalBytesReceivedSoFar) {\n        // When processing a dynamic response, we don't know how large each\n        // individual segment is, so approximate by assiging each segment\n        // the average of the total response size.\n        if (fulfilledEntries === null) {\n          // Haven't received enough data yet to know which segments\n          // were included.\n          return\n        }\n        const averageSize = totalBytesReceivedSoFar / fulfilledEntries.length\n        for (const entry of fulfilledEntries) {\n          segmentCacheLru.updateSize(entry, averageSize)\n        }\n      }\n    )\n    const serverData = await (createFromNextReadableStream(\n      prefetchStream\n    ) as Promise<NavigationFlightResponse>)\n\n    // Aside from writing the data into the cache, this function also returns\n    // the entries that were fulfilled, so we can streamingly update their sizes\n    // in the LRU as more data comes in.\n    fulfilledEntries = writeDynamicRenderResponseIntoCache(\n      Date.now(),\n      response,\n      serverData,\n      route,\n      spawnedEntries\n    )\n\n    // Return a promise that resolves when the network connection closes, so\n    // the scheduler can track the number of concurrent network connections.\n    return { value: null, closed: closed.promise }\n  } catch (error) {\n    rejectSegmentEntriesIfStillPending(spawnedEntries, Date.now() + 10 * 1000)\n    return null\n  }\n}\n\nfunction writeDynamicTreeResponseIntoCache(\n  now: number,\n  response: Response,\n  serverData: NavigationFlightResponse,\n  entry: PendingRouteCacheEntry,\n  couldBeIntercepted: boolean,\n  canonicalUrl: string,\n  routeIsPPREnabled: boolean\n) {\n  if (serverData.b !== getAppBuildId()) {\n    // The server build does not match the client. Treat as a 404. During\n    // an actual navigation, the router will trigger an MPA navigation.\n    // TODO: Consider moving the build ID to a response header so we can check\n    // it before decoding the response, and so there's one way of checking\n    // across all response types.\n    rejectRouteCacheEntry(entry, now + 10 * 1000)\n    return\n  }\n  const normalizedFlightDataResult = normalizeFlightData(serverData.f)\n  if (\n    // A string result means navigating to this route will result in an\n    // MPA navigation.\n    typeof normalizedFlightDataResult === 'string' ||\n    normalizedFlightDataResult.length !== 1\n  ) {\n    rejectRouteCacheEntry(entry, now + 10 * 1000)\n    return\n  }\n  const flightData = normalizedFlightDataResult[0]\n  if (!flightData.isRootRender) {\n    // Unexpected response format.\n    rejectRouteCacheEntry(entry, now + 10 * 1000)\n    return\n  }\n\n  const flightRouterState = flightData.tree\n  // TODO: Extract to function\n  const staleTimeHeaderSeconds = response.headers.get(\n    NEXT_ROUTER_STALE_TIME_HEADER\n  )\n  const staleTimeMs =\n    staleTimeHeaderSeconds !== null\n      ? parseInt(staleTimeHeaderSeconds, 10) * 1000\n      : STATIC_STALETIME_MS\n  fulfillRouteCacheEntry(\n    entry,\n    convertRootFlightRouterStateToRouteTree(flightRouterState),\n    flightData.head,\n    flightData.isHeadPartial,\n    now + staleTimeMs,\n    couldBeIntercepted,\n    canonicalUrl,\n    routeIsPPREnabled\n  )\n}\n\nfunction rejectSegmentEntriesIfStillPending(\n  entries: Map<string, SegmentCacheEntry>,\n  staleAt: number\n): Array<FulfilledSegmentCacheEntry> {\n  const fulfilledEntries = []\n  for (const entry of entries.values()) {\n    if (entry.status === EntryStatus.Pending) {\n      rejectSegmentCacheEntry(entry, staleAt)\n    } else if (entry.status === EntryStatus.Fulfilled) {\n      fulfilledEntries.push(entry)\n    }\n  }\n  return fulfilledEntries\n}\n\nfunction writeDynamicRenderResponseIntoCache(\n  now: number,\n  response: Response,\n  serverData: NavigationFlightResponse,\n  route: FulfilledRouteCacheEntry,\n  spawnedEntries: Map<string, PendingSegmentCacheEntry>\n): Array<FulfilledSegmentCacheEntry> | null {\n  if (serverData.b !== getAppBuildId()) {\n    // The server build does not match the client. Treat as a 404. During\n    // an actual navigation, the router will trigger an MPA navigation.\n    // TODO: Consider moving the build ID to a response header so we can check\n    // it before decoding the response, and so there's one way of checking\n    // across all response types.\n    rejectSegmentEntriesIfStillPending(spawnedEntries, now + 10 * 1000)\n    return null\n  }\n  const flightDatas = normalizeFlightData(serverData.f)\n  if (typeof flightDatas === 'string') {\n    // This means navigating to this route will result in an MPA navigation.\n    // TODO: We should cache this, too, so that the MPA navigation is immediate.\n    return null\n  }\n  for (const flightData of flightDatas) {\n    const seedData = flightData.seedData\n    if (seedData !== null) {\n      // The data sent by the server represents only a subtree of the app. We\n      // need to find the part of the task tree that matches the response.\n      //\n      // segmentPath represents the parent path of subtree. It's a repeating\n      // pattern of parallel route key and segment:\n      //\n      //   [string, Segment, string, Segment, string, Segment, ...]\n      const segmentPath = flightData.segmentPath\n      let segmentKey = ROOT_SEGMENT_KEY\n      for (let i = 0; i < segmentPath.length; i += 2) {\n        const parallelRouteKey: string = segmentPath[i]\n        const segment: FlightRouterStateSegment = segmentPath[i + 1]\n        segmentKey = encodeChildSegmentKey(\n          segmentKey,\n          parallelRouteKey,\n          encodeSegment(segment)\n        )\n      }\n      const staleTimeHeaderSeconds = response.headers.get(\n        NEXT_ROUTER_STALE_TIME_HEADER\n      )\n      const staleTimeMs =\n        staleTimeHeaderSeconds !== null\n          ? parseInt(staleTimeHeaderSeconds, 10) * 1000\n          : STATIC_STALETIME_MS\n      writeSeedDataIntoCache(\n        now,\n        route,\n        now + staleTimeMs,\n        seedData,\n        segmentKey,\n        spawnedEntries\n      )\n    }\n  }\n  // Any entry that's still pending was intentionally not rendered by the\n  // server, because it was inside the loading boundary. Mark them as rejected\n  // so we know not to fetch them again.\n  // TODO: If PPR is enabled on some routes but not others, then it's possible\n  // that a different page is able to do a per-segment prefetch of one of the\n  // segments we're marking as rejected here. We should mark on the segment\n  // somehow that the reason for the rejection is because of a non-PPR prefetch.\n  // That way a per-segment prefetch knows to disregard the rejection.\n  const fulfilledEntries = rejectSegmentEntriesIfStillPending(\n    spawnedEntries,\n    now + 10 * 1000\n  )\n  return fulfilledEntries\n}\n\nfunction writeSeedDataIntoCache(\n  now: number,\n  route: FulfilledRouteCacheEntry,\n  staleAt: number,\n  seedData: CacheNodeSeedData,\n  key: string,\n  entriesOwnedByCurrentTask: Map<string, PendingSegmentCacheEntry>\n) {\n  // This function is used to write the result of a dynamic server request\n  // (CacheNodeSeedData) into the prefetch cache. It's used in cases where we\n  // want to treat a dynamic response as if it were static. The two examples\n  // where this happens are <Link prefetch={true}> (which implicitly opts\n  // dynamic data into being static) and when prefetching a PPR-disabled route\n  const rsc = seedData[1]\n  const loading = seedData[3]\n  const isPartial = rsc === null\n\n  // We should only write into cache entries that are owned by us. Or create\n  // a new one and write into that. We must never write over an entry that was\n  // created by a different task, because that causes data races.\n  const ownedEntry = entriesOwnedByCurrentTask.get(key)\n  if (ownedEntry !== undefined) {\n    fulfillSegmentCacheEntry(ownedEntry, rsc, loading, staleAt, isPartial)\n  } else {\n    // There's no matching entry. Attempt to create a new one.\n    const possiblyNewEntry = readOrCreateSegmentCacheEntry(now, route, key)\n    if (possiblyNewEntry.status === EntryStatus.Empty) {\n      // Confirmed this is a new entry. We can fulfill it.\n      const newEntry = possiblyNewEntry\n      fulfillSegmentCacheEntry(newEntry, rsc, loading, staleAt, isPartial)\n    } else {\n      // There was already an entry in the cache. But we may be able to\n      // replace it with the new one from the server.\n      const newEntry = fulfillSegmentCacheEntry(\n        createDetachedSegmentCacheEntry(staleAt),\n        rsc,\n        loading,\n        staleAt,\n        isPartial\n      )\n      upsertSegmentEntry(now, key, newEntry)\n    }\n  }\n  // Recursively write the child data into the cache.\n  const seedDataChildren = seedData[2]\n  if (seedDataChildren !== null) {\n    for (const parallelRouteKey in seedDataChildren) {\n      const childSeedData = seedDataChildren[parallelRouteKey]\n      if (childSeedData !== null) {\n        const childSegment = childSeedData[0]\n        writeSeedDataIntoCache(\n          now,\n          route,\n          staleAt,\n          childSeedData,\n          encodeChildSegmentKey(\n            key,\n            parallelRouteKey,\n            encodeSegment(childSegment)\n          ),\n          entriesOwnedByCurrentTask\n        )\n      }\n    }\n  }\n}\n\nasync function fetchSegmentPrefetchResponse(\n  href: NormalizedHref,\n  segmentPath: string,\n  nextUrl: NormalizedNextUrl | null\n): Promise<Response | null> {\n  const headers: RequestHeaders = {\n    [RSC_HEADER]: '1',\n    [NEXT_ROUTER_PREFETCH_HEADER]: '1',\n    [NEXT_ROUTER_SEGMENT_PREFETCH_HEADER]: segmentPath,\n  }\n  if (nextUrl !== null) {\n    headers[NEXT_URL] = nextUrl\n  }\n  return fetchPrefetchResponse(href, headers)\n}\n\nasync function fetchPrefetchResponse(\n  href: NormalizedHref,\n  headers: RequestHeaders\n): Promise<Response | null> {\n  const fetchPriority = 'low'\n  const response = await createFetch(new URL(href), headers, fetchPriority)\n  const contentType = response.headers.get('content-type')\n  const isFlightResponse =\n    contentType && contentType.startsWith(RSC_CONTENT_TYPE_HEADER)\n  if (!response.ok || !isFlightResponse) {\n    return null\n  }\n  return response\n}\n\nfunction createPrefetchResponseStream(\n  originalFlightStream: ReadableStream<Uint8Array>,\n  onStreamClose: () => void,\n  onResponseSizeUpdate: (size: number) => void\n): ReadableStream<Uint8Array> {\n  // When PPR is enabled, prefetch streams may contain references that never\n  // resolve, because that's how we encode dynamic data access. In the decoded\n  // object returned by the Flight client, these are reified into hanging\n  // promises that suspend during render, which is effectively what we want.\n  // The UI resolves when it switches to the dynamic data stream\n  // (via useDeferredValue(dynamic, static)).\n  //\n  // However, the Flight implementation currently errors if the server closes\n  // the response before all the references are resolved. As a cheat to work\n  // around this, we wrap the original stream in a new stream that never closes,\n  // and therefore doesn't error.\n  //\n  // While processing the original stream, we also incrementally update the size\n  // of the cache entry in the LRU.\n  let totalByteLength = 0\n  const reader = originalFlightStream.getReader()\n  return new ReadableStream({\n    async pull(controller) {\n      while (true) {\n        const { done, value } = await reader.read()\n        if (!done) {\n          // Pass to the target stream and keep consuming the Flight response\n          // from the server.\n          controller.enqueue(value)\n\n          // Incrementally update the size of the cache entry in the LRU.\n          // NOTE: Since prefetch responses are delivered in a single chunk,\n          // it's not really necessary to do this streamingly, but I'm doing it\n          // anyway in case this changes in the future.\n          totalByteLength += value.byteLength\n          onResponseSizeUpdate(totalByteLength)\n          continue\n        }\n        // The server stream has closed. Exit, but intentionally do not close\n        // the target stream. We do notify the caller, though.\n        onStreamClose()\n        return\n      }\n    },\n  })\n}\n\nfunction createPromiseWithResolvers<T>(): PromiseWithResolvers<T> {\n  // Shim of Stage 4 Promise.withResolvers proposal\n  let resolve: (value: T | PromiseLike<T>) => void\n  let reject: (reason: any) => void\n  const promise = new Promise<T>((res, rej) => {\n    resolve = res\n    reject = rej\n  })\n  return { resolve: resolve!, reject: reject!, promise }\n}\n"],"names":["EntryStatus","FetchStrategy","convertRouteTreeToFlightRouterState","createDetachedSegmentCacheEntry","fetchRouteOnCacheMiss","fetchSegmentOnCacheMiss","fetchSegmentPrefetchesUsingDynamicRequest","getCurrentCacheVersion","readExactRouteCacheEntry","readOrCreateRevalidatingSegmentEntry","readOrCreateRouteCacheEntry","readOrCreateSegmentCacheEntry","readRouteCacheEntry","readSegmentCacheEntry","resetRevalidatingSegmentEntry","revalidateEntireCache","upgradeToPendingSegment","upsertSegmentEntry","waitForSegmentCacheEntry","routeCacheMap","createTupleMap","maxRouteLruSize","routeCacheLru","createLRU","onRouteLRUEviction","segmentCacheMap","Map","maxSegmentLruSize","segmentCacheLru","onSegmentLRUEviction","currentCacheVersion","nextUrl","tree","pingVisibleLinks","now","href","keypath","existingEntry","get","staleAt","put","deleteRouteFromCache","key","nonInterceptedEntry","couldBeIntercepted","path","undefined","revalidatingEntry","revalidating","upsertedEntry","deleteSegmentFromCache","readRevalidatingSegmentCacheEntry","owner","existingRevalidation","clearRevalidatingSegmentFromOwner","pendingEntry","promiseWithResolvers","promise","createPromiseWithResolvers","task","canonicalUrl","status","blockedTasks","head","isHeadPartial","Infinity","isPPREnabled","next","prev","size","set","route","prevEntry","segmentKeyPath","candidateEntry","isPartial","rejectedEntry","loading","rsc","emptyEntry","fetchStrategy","entry","pingBlockedTasks","delete","cancelEntryListeners","revalidatingSegment","resolve","pingPrefetchTask","fulfillRouteCacheEntry","fulfilledEntry","fulfillSegmentCacheEntry","segmentCacheEntry","rejectRouteCacheEntry","rejectSegmentCacheEntry","convertRootTreePrefetchToRouteTree","rootTree","convertTreePrefetchToRouteTree","ROOT_SEGMENT_KEY","prefetch","slots","prefetchSlots","parallelRouteKey","childPrefetch","childSegment","segment","childKey","encodeChildSegmentKey","encodeSegment","isRootLayout","convertRootFlightRouterStateToRouteTree","flightRouterState","convertFlightRouterStateToRouteTree","parallelRoutes","childRouterState","childTree","routeTree","response","fetchSegmentPrefetchResponse","ok","body","Date","redirected","createHrefFromUrl","urlToUrlWithoutFlightMarker","url","varyHeader","headers","includes","NEXT_URL","closed","routeIsPPREnabled","NEXT_DID_POSTPONE_HEADER","prefetchStream","createPrefetchResponseStream","onResponseSizeUpdate","updateSize","serverData","createFromNextReadableStream","buildId","getAppBuildId","staleTimeMs","staleTime","writeDynamicTreeResponseIntoCache","currentKeypath","expectedEntry","newKeypath","value","error","routeKey","dynamicRequestTree","spawnedEntries","RSC_HEADER","NEXT_ROUTER_STATE_TREE_HEADER","encodeURIComponent","JSON","stringify","NEXT_ROUTER_PREFETCH_HEADER","fetchPrefetchResponse","rejectSegmentEntriesIfStillPending","fulfilledEntries","totalBytesReceivedSoFar","averageSize","length","writeDynamicRenderResponseIntoCache","b","normalizedFlightDataResult","normalizeFlightData","f","flightData","isRootRender","staleTimeHeaderSeconds","NEXT_ROUTER_STALE_TIME_HEADER","parseInt","STATIC_STALETIME_MS","entries","values","push","flightDatas","seedData","segmentPath","segmentKey","i","writeSeedDataIntoCache","entriesOwnedByCurrentTask","ownedEntry","possiblyNewEntry","newEntry","seedDataChildren","childSeedData","NEXT_ROUTER_SEGMENT_PREFETCH_HEADER","fetchPriority","createFetch","URL","contentType","isFlightResponse","startsWith","RSC_CONTENT_TYPE_HEADER","originalFlightStream","onStreamClose","totalByteLength","reader","getReader","ReadableStream","pull","controller","done","read","enqueue","byteLength","reject","Promise","res","rej"],"mappings":"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"}