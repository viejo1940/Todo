{"version":3,"sources":["../../../src/lib/metadata/async-metadata.tsx"],"sourcesContent":["'use client'\n\nimport { Suspense, use } from 'react'\nimport { useServerInsertedMetadata } from '../../server/app-render/metadata-insertion/use-server-inserted-metadata'\n\nexport type StreamingMetadataResolvedState = {\n  metadata: React.ReactNode\n  error: unknown | null\n  digest: string | undefined\n}\n\nfunction ServerInsertMetadata({\n  promise,\n}: {\n  promise: Promise<StreamingMetadataResolvedState>\n}) {\n  // Apply use() to the metadata promise to suspend the rendering in SSR.\n  const { metadata } = use(promise)\n  // Insert metadata into the HTML stream through the `useServerInsertedMetadata`\n  useServerInsertedMetadata(() => metadata)\n\n  return null\n}\n\nfunction BrowserResolvedMetadata({\n  promise,\n}: {\n  promise: Promise<StreamingMetadataResolvedState>\n}) {\n  const { metadata, error } = use(promise)\n  // If there's metadata error on client, discard the browser metadata\n  // and let metadata outlet deal with the error. This will avoid the duplication metadata.\n  if (error) return null\n  return metadata\n}\n\nexport function AsyncMetadata({\n  promise,\n}: {\n  promise: Promise<StreamingMetadataResolvedState>\n}) {\n  return (\n    <>\n      {typeof window === 'undefined' ? (\n        <ServerInsertMetadata promise={promise} />\n      ) : (\n        <BrowserResolvedMetadata promise={promise} />\n      )}\n    </>\n  )\n}\n\nfunction MetadataOutlet({\n  promise,\n}: {\n  promise: Promise<StreamingMetadataResolvedState>\n}) {\n  const { error, digest } = use(promise)\n  if (error) {\n    if (digest) {\n      // The error will lose its original digest after passing from server layer to client layerï¼›\n      // We recover the digest property here to override the React created one if original digest exists.\n      ;(error as any).digest = digest\n    }\n    throw error\n  }\n  return null\n}\n\nexport function AsyncMetadataOutlet({\n  promise,\n}: {\n  promise: Promise<StreamingMetadataResolvedState>\n}) {\n  return (\n    <Suspense fallback={null}>\n      <MetadataOutlet promise={promise} />\n    </Suspense>\n  )\n}\n"],"names":["AsyncMetadata","AsyncMetadataOutlet","ServerInsertMetadata","promise","metadata","use","useServerInsertedMetadata","BrowserResolvedMetadata","error","window","MetadataOutlet","digest","Suspense","fallback"],"mappings":"AAAA;;;;;;;;;;;;;;;;IAoCgBA,aAAa;eAAbA;;IAiCAC,mBAAmB;eAAnBA;;;;uBAnEc;2CACY;AAQ1C,SAASC,qBAAqB,EAC5BC,OAAO,EAGR;IACC,uEAAuE;IACvE,MAAM,EAAEC,QAAQ,EAAE,GAAGC,IAAAA,UAAG,EAACF;IACzB,+EAA+E;IAC/EG,IAAAA,oDAAyB,EAAC,IAAMF;IAEhC,OAAO;AACT;AAEA,SAASG,wBAAwB,EAC/BJ,OAAO,EAGR;IACC,MAAM,EAAEC,QAAQ,EAAEI,KAAK,EAAE,GAAGH,IAAAA,UAAG,EAACF;IAChC,oEAAoE;IACpE,yFAAyF;IACzF,IAAIK,OAAO,OAAO;IAClB,OAAOJ;AACT;AAEO,SAASJ,cAAc,EAC5BG,OAAO,EAGR;IACC,qBACE;kBACG,OAAOM,WAAW,4BACjB,qBAACP;YAAqBC,SAASA;2BAE/B,qBAACI;YAAwBJ,SAASA;;;AAI1C;AAEA,SAASO,eAAe,EACtBP,OAAO,EAGR;IACC,MAAM,EAAEK,KAAK,EAAEG,MAAM,EAAE,GAAGN,IAAAA,UAAG,EAACF;IAC9B,IAAIK,OAAO;QACT,IAAIG,QAAQ;YACV,2FAA2F;YAC3F,mGAAmG;;YACjGH,MAAcG,MAAM,GAAGA;QAC3B;QACA,MAAMH;IACR;IACA,OAAO;AACT;AAEO,SAASP,oBAAoB,EAClCE,OAAO,EAGR;IACC,qBACE,qBAACS,eAAQ;QAACC,UAAU;kBAClB,cAAA,qBAACH;YAAeP,SAASA;;;AAG/B"}